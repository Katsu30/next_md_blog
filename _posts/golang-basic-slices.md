---
title: '【Go】基本的なスライス型の使い方'
excerpt: '基本的なスライス型を確認して、配列の操作で必要な点だったり'
coverImage: '/assets/blog/golang/golang_top_image.png'
date: '2023-05-02'
ogImage:
  url: '/assets/blog/golang/golang_top_image.png'
tags:
  - 'Go'
---

## 概要

『[初めての Go 言語](https://amzn.to/3LpcrlM)』という本を Go 言語の復習がてら読んでたので、気になったところや勉強したところをメモに残していきます。

![初めてのGo言語](/assets/blog/golang/40004_learning_go_cvr.jpg)

### `Slice` の使いどころ

実務上ではよく使用する`slice`。
単に「配列」としか認識していませんでしたが、具体的には「可変長の配列」とのこと。

```go
var x = []int{10, 20, 30}
```

たしかに、`append`をしたり、`len`だったりを確認するのはこの形のスライスだけだったなと改めて気が付きました。

`slice`の注意点としては、下記が上げられるかなと。

1. 初期値は指定しなければ `nil`
2. スライスと比較できるのは `nil` のみ

これは、初期値が`nil`に起因しているようですね。

### `slice`で使用できるメソッド

- `len`
- `append`

`len`は、配列の長さを確認するための関数です。
`TypeScript`で言う`length`ですね。使い方も同じように使用できるので、特に難しいことはなさそう。
使いどころとしては、レスポンスを返す際に配列要素がない場合にエラーを返したりする場合でしょうか。

```go
if (array.len == 0) return fmt.Errorln('error was occured.')
```

`append`は、配列に要素を追加するための関数。`TypeScript`で言う`push`です。

基本的な使い方は下記の通り。

```go
var x = []int{1, 2, 3}
x = append(x, 4) // {1, 2, 3, 4}
x = append(x, 5, 6, 7) // {1, 2, 3, 4, 5, 6, 7}
```

演算子の`...`を使用することで、別スライスの値を展開して追加することができます。

```go
var x = []int{1, 2, 3}
var y = []int{10, 20, 30}
x = append(x, y...) // {1, 2, 3, 10, 20, 30}
```

### スライスのスライス

スライスから新しいスライスを作成するためには、`[n:m]`の形式で作成する。
`n`にはスライスの開始の配列番号を、`m`にはスライスの終了の配列番号を追加します。

```go
x := []int{1, 2, 3, 4}
a := x[:2]
b := x[1:]
c := x[1:3]

fmt.Println(a) // [1, 2]
fmt.Println(b) // [2, 3, 4]
fmt.Println(c) // [2, 3]
```

上記のような書き方もできますが、スライスは**メモリを共有する**という特徴があるので、`append`や代入をサブスライス（作成されたスライス）に行う場合は、**フルスライス式**を使用したほうが懸命です。

フルスライス式は、`[n:m:o]`の`o`にキャパシティを追加して作成するスライスです。

```go
x := []int{1, 2, 3, 4}
a := x[:2:2]
b := x[2:4:4]

a = append(a, 30, 40, 50)
b = append(b, 60)

fmt.Println(a) // 1, 2, 30, 40, 50
fmt.Println(b) // 3, 4, 60
```

## まとめ

備忘録として基本的なスライスの記述方法をまとめました。
普段、フロントエンド寄りの技術を使用しているので、メモリの話など少し難しい部分がありますが、きちんと理解しておかないとここからの Gopher 道に影響が出そうなので、しっかりと学んでいきたいですね。

[![初めてのGo言語](/assets/blog/golang/40004_learning_go_cvr.jpg)](https://amzn.to/3LpcrlM)
